[
{
	"uri": "https://bbb-86-ko.github.io/",
	"title": "",
	"tags": [],
	"description": "",
	"content": "I am BBB what is my goal? sin prisa, pero sin pausa\n서두르지 말고, 멈추지도 말라\n"
},
{
	"uri": "https://bbb-86-ko.github.io/%EA%B0%9C%EB%B0%9C%EC%9E%90/",
	"title": "개발자",
	"tags": [],
	"description": "",
	"content": "개발자 what is my goal? 안주하지 않고 멈추지 않고 근성으로\n"
},
{
	"uri": "https://bbb-86-ko.github.io/%EA%B8%88%EC%9C%B5%EC%96%B4%EB%A6%B0%EC%9D%B4/",
	"title": "금(융어)린이",
	"tags": [],
	"description": "",
	"content": "금(융어)린이의 투자공부 what is my goal? 10년 20년을 목표로 투자 공부를 지속하자\n"
},
{
	"uri": "https://bbb-86-ko.github.io/%EA%B8%88%EC%9C%B5%EC%96%B4%EB%A6%B0%EC%9D%B4/%EB%8F%85%EC%84%9C/",
	"title": "독서",
	"tags": [],
	"description": "",
	"content": "금린이의 투자공부 - 독서 Basics Discover what this Hugo theme is all about and the core-concepts behind it.\n"
},
{
	"uri": "https://bbb-86-ko.github.io/%EA%B8%88%EC%9C%B5%EC%96%B4%EB%A6%B0%EC%9D%B4/%EB%8F%85%EC%84%9C/%ED%88%AC%EC%9E%90%EC%97%90%EB%8C%80%ED%95%9C%EC%83%9D%EA%B0%81/01.-%EC%8B%AC%EC%B8%B5%EC%A0%81%EC%9C%BC%EB%A1%9C-%EC%83%9D%EA%B0%81%ED%95%98%EB%9D%BC/",
	"title": "01. 심층적으로 생각하라",
	"tags": [],
	"description": "",
	"content": "투자 전략은 직관적이고 유연해야한다. 투자에는 언제나 적용 가능한 규칙은 없다.\n환경은 통제불가능하고 상황이 똑같이 반복되는 일은 드물기때문이다.\n또한 투자자의 심리가 시장에서 중요하게 작용하고 많은 변수에 영향을 받는다.\n그래서 투자 전략은 지속되지 않고 공식화 할 수 없다.\n그렇기 때문에 투자 전략은 직관적이고 유연해야한다.\n2차 사고(second-level thinking) 2차 사고는 다른 투자자들보다 더 현명하게 사고하는 것이며 남들과 다르면서 남들보다 더 나아가있는 것이다.\n성공적인 투자자는 시장 또는 다른투자자 보다 높은 수익을 낸다.\n그런데 성공적인 투자자는 운일수도 있고 탁월한 통찰력일 수 있다.\n성공적인 투자자가 되려면 탁월한 통찰력에 집중을 해야하면 이를 2차 사고라 할 수 있다.\n다만, 탁월한 통찰력은 누가 가르친다고 생기는 것은 아니며 남들보다 투자에 대한 이해력이 뛰어난 사람이다.\n결론 투자의 목적은 평균이 아닌 평균이상의 수익을 내는것이라 한다면 이를 달성하기 위해서는 2차 사고가 필요하다.\n"
},
{
	"uri": "https://bbb-86-ko.github.io/%EA%B8%88%EC%9C%B5%EC%96%B4%EB%A6%B0%EC%9D%B4/%EB%8F%85%EC%84%9C/%ED%88%AC%EC%9E%90%EC%97%90%EB%8C%80%ED%95%9C%EC%83%9D%EA%B0%81/02.-%EC%8B%9C%EC%9E%A5%EC%9D%98-%ED%9A%A8%EC%9C%A8%EC%84%B1%EC%9D%84-%EC%9D%B4%ED%95%B4%ED%95%98%EB%9D%BC/",
	"title": "02. 시장의 효율성을 이해하라",
	"tags": [],
	"description": "",
	"content": "이론적으로는 이론과 실제 사이에 차이가 없지만, 실제로는 차이가 있다. -요기 베라-  요약 효율적 시장 가설과 비효율적 관점을 비교하고 시장의 비효율성을 증명하였다. 또한 이러한 이론에 투자자의 자세를 말하고 있다.\n시카고 학파의 이론 위험 회피, 위험 요소로서의 변동성, 위험조정수익, 체계적 위험과 비체계적 위험, 알파(펀드매니저가 시장수익률을 상회하는 수익을 올렸을 때 이를 표현한 수치), 베타(개별 주식이나 포트폴리오의 민감도를 나타내는 상대적 지표), 랜덤워크 가설(randomwalk hypothesis: 시장과 주가는 과거나 패턴에 제약을 받지 않고 독립적으로 움직인다는 가설), 효율적 시장가설(efficient market hypothesis: 주가가 이용 가능한 모든 정보를 반영하며, 시장은 새로운 정보에 즉각 반응한다고 보는 가설)\n효율적 시장 가설   시장에는 많은 참여자가 있다. 이들은 정보에 균등한다. 또한 현명하고 객관적이며 의욕이 넘치고 열심히 노력한다.\n  이런 시장 참여자의 노력으로 모든 정보가 자산의 시장 가격에 충분히 반영되고 자산 가격은 공정하게 매겨진다.\n  시장 가격은 내재가치를 정확하게 평가한 것이다. 그래서 어떠한 참가자도 평가가 잘못된 경우를 지속적으로 발견하여 그로부터 이익을 보는 일은 있을 수 없다.\n  자산은 다른 자산과 비교하여 fair한 위험 조정 수익을 낼 것으로 기대되는 가격에 팔린다. 이는 리스크가 증가하지 않으면 수익도 증가하지 않는 다는 것이다.\n  효율적 시장 가설 안에서는   시장을 예측하면 -\u0026gt; 평균 수익률 달성.\n  시장을 이기려면 -\u0026gt; 시장의 예측과 반대되는 견해 필요.\n즉 시장이 자산을 잘못 평가해도 참여자가 같은 정보, 같은 심리적 영향을 받고 시장의 예측과 다르면서 좀 더 정확한 경해를 지속적으로 갖기 어렵다.\n  인덱스 펀드의 탄생 시장을 이길 수 없다는 판단 아래 소극적 투자기법 인덱스 펀드가 탄생되었다.\n효율적 시장 가설의 취약점   객관성\n인간은 단순한 기계가 아니다. 객관성을 잃게하는 감정에 영향을 받고 큰 실수를 한다.\n  모든 자산에 투자 가능\n현실과 다르다.\n이런 취약점으로 통찰(2차적사고) 사람은 시장을 이긴다.\n  비효율적 시장  시장 가격이 종종 잘못 책정되는 경우가 있다. 자산은 종종 공정하지 않은 가격으로 평가되기 때문에, 하나의 자산군이 다른 자산군에 비해 지나치게 높거나 지나치게 낮은 위험 조정 수익을 낼 수 있다. 어떤 투자자들은 계속해서 다른 투자자들보다 나은 수익을 달성할 수 있다. 잘못된 평가, 기술, 통찰력, 정보 접근 등의 차이 이를 발견하고 지속적으로 이익을 취할 수 있는 가능성이 있다.  비효율적 시장의 요점 비효율성은 성공적인 투자를 위한 필요조건이다. 하지만 초과성과를 달성하기 위한 충분조건은 될 수 없다. 초과 성괄르 달성하기 위한 충분조건은 비효율성 안에서 저가 매수를 꾸준히 할 수 있는 통찰력(2차적사고)이다.  이론을 대하는 자세 이론은 우리의 결정에 필요한 정보를 제공하는 역할은 할 수 있지만 결정을 좌우해서는 안된다.\n 이론을 무시 : 잘못된 판단으로 큰 실수를 저지를 수 있다. (리스크 무시, 증권 50주를 매입하고 분산투자했다고 착각) 이론을 맹신 : 저가 매수 기회를 찾으려는 노력조차 하지 않고 투자 프로세스를 컴퓨터에 넘길 수 있다. 또한 개인의 기여를 인정하지 않을 수도 있다.  결론 효율적 시장 가설의 취약점으로 시장은 실수를 할 수 있다. 이로 인해 비효율적인 시장 환경이 만들어지고 이는 성공적인 투자를 할 수 있는 상태를 만든다. 하지만 이러한 환경에서 누구나 초과성과를 달성할 수는 없다. 2차적사고를 가진 사람만이 비효율성 안에서 꾸준한 저가 매수로 초과성과를 달성한다.\n"
},
{
	"uri": "https://bbb-86-ko.github.io/%EA%B8%88%EC%9C%B5%EC%96%B4%EB%A6%B0%EC%9D%B4/%EB%8F%85%EC%84%9C/%ED%88%AC%EC%9E%90%EC%97%90%EB%8C%80%ED%95%9C%EC%83%9D%EA%B0%81/03.-%EA%B0%80%EC%B9%98%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80/",
	"title": "03. 가치란 무엇인가",
	"tags": [],
	"description": "",
	"content": "투자에서 확실히 성공하려면 가장 먼저 내재가치의 정확한 평가가 이루어져야 한다. 정확한 내재가치 평가 없이 투자자로서 지속적인 성공을 희망하는 것은 말 그대로 희만일 뿐이다.  요약 이번 장에서는 분석방법과 투자방법에 대한 이야기를 하며 내재가치 평가의 중요성에 대하여 기술하였다.\n분석 방법   기본적분석\n 기업의 가치를 분석하는 것이다. 매수 전략 : 기본 내재가치가 가격과 동떨어질때 매수를 한다.    기술적분석\n 증권가격의 동향 분석하는 것이다. 매수 전략 : 미래의 증권가격 동향을 얘측하고 매수를 한다.    기술적분석의 쇠퇴 기술적분석은 과거의 주가의 동향을 분석하여 미래를 예측하게 되는 것인데 이는 마치 동전던지기를 하는 것과 다르지 않다.\n# 랜덤워크 가설 # 과거의 주가 동향은 미래의 주가를 예측하는 데 아무런 도움이 되지 않는다.  증권을 가치 있게 만드는 것은 무엇인가? 자원, 경영진, 공장, 소매상, 특허, 인재, 브랜드인지도, 성장가능성 그리고 소득과 현금유동성을 창출할 수 있는 능력이다.\n기본적 분석   가치투자\n 내재가치보다 싼 증권에 투자를 한다. 재무재표를 활용하여 기업의 현재가치를 수량화 하여 내재가치를 판단하고 가격이 싸다고 판단하면 투자를 한다. 유형자산, 현금유동성을 중요하게 생각한다. 순운전자본투자(net-net- investing)    성장투자\n 가치투자와 모멘텀투자 중간쯤에 있다. 미래의 가치가 빠르게 상승할 증권에 투자를 한다. 잠재력, 장미 빛 미래와 같은 미래의 가치에 투자를 한다.    공통점\n 두가지 모두 내재가치에 대한 판단은 필요하고 미래를 대상으로 하고 있다.    차이점\n 가치투자는 미래보다 현재가 낮은 상황이고, 성장투자는 현재보다 미래가 높은 상황이다. 성장투자자의 성공률은 낮다. 현재보다 미래를 아는 것이 더 어렵기 때문이다.    가치투자 쉬운가? NO 가치투자의 수익 = [내재가치에 대한 정확한 판단] + [확고한 신념]   정확하게 평가하는 것이 중요하다. 자산을 계속 보유해야한다.  내재가치를 올바르게 평가를 하였다고 해도 지금 당장 옳다고 입증되지는 않는다.   확고한 신념이 있어야한다.  확고한 신념으로 수익이 발생하지 않는 기간을 버텨야한다.    결론 미래의 주가를 판단할때 과거 주가의 동향으로 판단하는 것은 좋지 못하다.\n투자에 있어 내재가치 평가는 중요하며 평가 결과는 정확해야 한다.\n정확한 평가를 하여도 확고한 신념이 없으면 수익을 낼 수 없다.\n내재가치에 대한 정확한 판단과 확고한 신념이 함께 이루어져야 수익을 낼 수 잇다.\n"
},
{
	"uri": "https://bbb-86-ko.github.io/%EA%B8%88%EC%9C%B5%EC%96%B4%EB%A6%B0%EC%9D%B4/%EB%8F%85%EC%84%9C/%ED%88%AC%EC%9E%90%EC%97%90%EB%8C%80%ED%95%9C%EC%83%9D%EA%B0%81/04.-%EA%B0%80%EA%B2%A9%EA%B3%BC-%EA%B0%80%EC%B9%98-%EC%82%AC%EC%9D%B4%EC%9D%98-%EA%B4%80%EA%B3%84%EB%A5%BC-%EC%9D%B4%ED%95%B4%ED%95%98%EB%9D%BC/",
	"title": "04. 가격과 가치 사이의 관계를 이해하라",
	"tags": [],
	"description": "",
	"content": "투자의 성공은 '좋은 자산을 사는 것'이 아니라, '자산을 잘 사는 것'에서 나온다.  요약 가치와 가격의 관계를 이야기 하고있다. 투자에서 가치 판단은 중요하다. 다만 좋은 가치의 자산이라도 가치이상의 가격을 지불하게되면 투자에 성공을 보장하기 힘들다고 한다.\n성공적 투자란? 가치와 가격을 비교하고 건전한관계를 확립한 상황.  투자의 시작이란? 가치투자자에게 투자의 시작은 가격이어야 한다.\n너무 비싸게 매입하고도 나쁜 투자는 아닐 만큼 좋은 자산은 없다.\n충분히 싸게 매입하고도 좋은 투자가 아닐 만큼 나쁜 자산은 없다.\n자산은 언제 매력적인가? 자산은 가격이 적당할 때만 매력적일 수 있다. 어떠한 자산도 고수익을 올릴 수 있는 선천적 권리는 없기 때문이다.\n(중고거래를 생각해볼 수 있다. 우리는 가격이 얼마인지 확인을 한다.)\n투자의 실수란? 가치에 비해 더 많이 지불하는 것이다.\n비싸게 주고 성공까지 가려면 매우 큰 노력 또는 큰 운이 따라야한다.\n(이러한 노력과 큰 운은 리스크가 커지는 것과 동일해 보인다.)\n저가 매수의 이점 잘 사기만 하면 절반은 판 것이나 다름없다. 가치가 좋아도 합리적 가격이 뒷받침해야한다.  보유 자산을 얼마에, 언제, 누구에게, 어떤방법으로 팔지 고심하는 시간을 줄여준다. 내재가치 평가가 정확하고 저가 매수를 했다면 시간이 지나면 자산의 가격을 자산의 가치와 부합할 것이다.\n가격의 요소   심리요인\n 미래가격동향 = 자산을 매입하고 싶은 사람이 많다. (인기가 많다.) 최악의 결과 = 최절정인기 매수 = 가격에 모든 장점 및 호평이 반영된 자산  가치 평가의 핵심은 숙련된 재무 분석이다. 가격과 가치의 관계를 이해하는 핵심은 다른 투자자들의 심리를 간파하는 것이다. 심리는 단기적으로 가치와 관계없이 증권 가격에 영향을 줄 수 있다.\n아무도 관심을 보이지 않을때 안전하고 잠재수익이 높다. 시장의 심리를 이해하기 위해 시간과 에너지를 투자해서 자신의 이점으로 활용할 수 있어야 한다.\n  기술적요인\n공급과 수요에 영향을 미치는 가치와 같은 요소와 상관없는 기타요소이다. 기술적 요인으로 가격과 상관없이 거래를 해야하는 상황이 나올 수 있고 아래와 같은 상황에 직면할 수 있다.\n 가격에 상관없이 어쩔 수 없이 매도하는 상황  타인이 이 상황이라면 우리에게는 최고의 상황이고 적극적으로 매수하면 된다. 만약 내가 이 상황이라면 우리는 최악의 상황인데 장기 자본과 강한 의지력으로 매도하지 않고 보유 할 수 있어야한다.\n(최악의 상황을 이겨내는 방법에 의문이 든다. 자산의 가치평가가 문제 없을때 가능한 상황이라 생각되며 모든 자산에 대해 이런방법이 가능하다 생각된다.)\n  성실한 가치투자의 반대 확실한 가치를 기반으로 한 투자 전략이 신뢰를 받는다.  가격과 가치 사이의 관계를 무시하고 발생한 거품을 추종하는 것이다.\n작은 진실로 시작된 거품의 예\n 튤립은 아름답고 고귀하다. 인터넷이 세상을 바꿀 것이다. 부동산은 계속해서 상승할 것이며, 우리에겐 살 집이 필요하다.  작은 진실로 다은과 같은 현상이 생긴다.\n 소수의 현명한 투자자들은 진실을 이해하고 수익을 낸다. 다른 사람들은 현명한 투자자들을 따라 자산을 매입하고 자산의 가격은 상승한다. 이 상황이 격앙되면 가격이 적당한지 파악을 하지 않고 결과적으로 극단적인 상황을 만든다.\n(투자에서는 가격이 오르면 더 찾는 경향이 있다.)  투자 수익을 낼 수 있는 방법과 문제점  자산의 내재가치 상승으로 얻는 혜택   문제점 : 가치 상승을 정확히 예측하기 어렵다. 또한 상승 잠재력에 대한 일반적인 견해가 자산 가격에 이미 반영된 경우가 많다. (일반적인 견해 : 본인의 견해나 타인의 견해가 다르지 않다.)  레버리지 이용   문제점 : 레버리지는 수익 가능성을 증가시키기 보다는 수익과 손실을 확대 시킨다.  가진 자산을 가치보다 비싸게 매각하는 것   문제점 : 가치이상으로 매입하려는 사람은 많지 않을 것이다.  가치에 비해 저가로 사는 것   문제점 : 가치를 잘못 평가할 수 있다. 가치 하락이 발생할 수있다.  위 방법 중에 가치에 비해 저가로 사는 것이 상대적으로 믿을 만하고 우리가 할 수 있는 최선의 선택이다. 자산이 적정가치에 부합을 했을때 수익이 창출되기 때문이다.\n결론  가치를 판단하는 것은 중요하다. 하지만 가치가 수익을 보장하지 않는다. 가격을 고려하지 않은 선택을 두고 옳고 그름을 평가하는 것은 의미가 없다. 가격을 판단하여 적정가격 또는 저가 매수를 해야한다. 시장의 심리를 이해하기 위한 노력을 해야한다. 타인이 \u0026ldquo;가격에 상관없이 매도하는 상황\u0026quot;은 내가 매수할 수 있는 기회이다. 가치에 비해 저가로 매수하는 것은 항상 수익을 보장하지는 못할 수 있지지만 최선의 선택이다.  "
},
{
	"uri": "https://bbb-86-ko.github.io/%EA%B8%88%EC%9C%B5%EC%96%B4%EB%A6%B0%EC%9D%B4/%EB%8F%85%EC%84%9C/%ED%88%AC%EC%9E%90%EC%97%90%EB%8C%80%ED%95%9C%EC%83%9D%EA%B0%81/05.%EB%A6%AC%EC%8A%A4%ED%81%AC%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80/",
	"title": "05. 리스크란 무엇인가?",
	"tags": [],
	"description": "",
	"content": "위험이란, 일어날 일보다 더 많은 일이 일어날 수 있음을 의미한다. -엘로이 딤슨, 런던비즈니스스쿨 교수-  요약 리스크에 대처하기 위해 리스크를 이해, 인지, 제어하려는 노력이 필요하다. 그래서 투자 전/후 그리고 진행하는 동안에도 자산에 대한 지속적인 리스크평가는 필요하다. 그런데 리스크는 계량화하기 어렵다.\n리스크에 대처하기 위해 해야하는 것  리스크 이해 리스크 인지 리스크 제어  리스크 평가가 필요한 이유 리스크는 나쁜것이고 사람은 본능적으로 위험을 회피하려고 한다. 그렇기 때문에 리스크의 양과 감소할 수 있는지 판단하고 직시해야 한다. 또한 투자 결과를 검토할 때 \u0026lsquo;위험조정 수익\u0026rsquo;을 평가 할 수 있어야 한다.\n일반적인 자본시장선(CML:capital market line)과 잘못된 생각 googlelink\n\u0026lsquo;높은 수익을 올리려면 더 큰 리스크를 부담해야한다.\u0026lsquo;라는 잘못된 결론을 낼 수 있다. 그런데 이건 그냥 \u0026lsquo;확실 한 투자\u0026rsquo;이다.\n하워드 막스(howard marks)의 자본시장선 googlelink\n높은 리스크가 높은 수익을 보장하지는 못하다는 것을 보여준다. 높은 리스크 1) 기대수익증가 2) 수익하락 3) 손실가능성 3가지가 발생할 가능성을 높여준다. 즉 높은 리스크는 수익의 불확실성이 크다.\n리스크의 정의 자본시장 리스크 = 변동성  하워드 막스 리스크 = 절대적으로 돈을 잃을 가능성(영구 손실에 대한 가능성)  변동성이 모든 리스크의 종류를 설명할 수 없다. 모든 종류의 리스크를 의식해야 한다.\n리스크의 종류 리스크는 나에게 영향을 미치기도 하지만 타인에게 영향을 미칠 수 있다. 나에게 영향은 없지만 타인에게 영향있는 리스크는 수익을 올릴 수 있는 기회를 준다.\n 목표에 못미치는 것 : 투자자가 목표한 수익을 달성하지 못했을 때 발생하는 리스크 이며, 주관적이고 상대적이다. 저조한 성과 : 투자전략이 기준이되는 지수에 미치지 못한 상황에서 발생하는 리스크를 말한다. 경력리스크 : \u0026lsquo;저조한 성과\u0026rsquo;의 극단적인 형태이다. 이례성 : 남들과 다르게 이례적인 행동은 리스크가 될 수있다. 하지만 좋은 기회를 만들기도 한다. 비유동성 : 적정가격으로 현금화 할 수 없는 상황에서 발생하는 리스크이며, 개인적이다. 알맞는 유동성을 갖는 투자를 해야한다.  무엇이 손실 위험을 낳는가? 손실위험 = 지나친 낙관 심리 + 지나치게 상승한 가격   펀더멘탈(fundamental:기초 경제 여건)이 부실해서 생기는 것은 아니다.\n저가매수를 한다면 펀더멘탈의 부실은 극복할 수 있는 부분이고 성공적인 투자를 할 수 있다. 자신의 포트폴리오가 어떻게 운용되는지 이해하는데 노력하지 않은 사람에게 1) 자만심, 2) 리스크를 모른채 수용하는 것, 3) 불리한 상황 이 발생하면 큰 피해가 발생할 수 있다.  가치투자자들의 생각 가치보다 싸게 매입 -\u0026gt; 고수익 + 저위험 가치보다 높게 매입 -\u0026gt; 저수익 + 고위험  매출 저조, No 관심, 평판 절가된 증권은 저가 매수 대상이 될 수 있다. 이러한 증권은 고점을 찍는 일은 드물지만 변동성과 리스크가 낮다고 시장이 불황일때 손실이 적다. 다만 강세장에서는 저조한 성과를 낼 가능성이 있다.\n리스크는 어떻게 평가해야 하는가? 많은 리스크가 주관적이고 보이지 않으며 계량화 될 수 없다. 다만 능력있는 투자자들은 \u0026lsquo;가치의 안정성과 신뢰성\u0026rsquo; 그리고 \u0026lsquo;가격과 가치의 관계\u0026rsquo;로 리스크를 판단한다.\n결론  리스크를 이해, 인지, 제어하려는 노력이 필요하다. 높은 리스크가 높은 수익을 보장하지는 못하다. 손실위험은 지나친 낙관심리와 지나치게 상승한 가격으로 발생한다. 가치투자는 고수익 + 저위험의 상태를 만들 수 있다. 리스크는 주관적이고 계량화 될 수 없다. \u0026lsquo;가치의 안정성과 신뢰성\u0026rsquo; 그리고 \u0026lsquo;가격과 가치의 관계\u0026rsquo;로 리스크를 판단해야 한다.  "
},
{
	"uri": "https://bbb-86-ko.github.io/%EA%B0%9C%EB%B0%9C%EC%9E%90/spring-boot/2.3.0/",
	"title": "2.3.X",
	"tags": [],
	"description": "",
	"content": "Spring Boot 2.3 Release Notes\nChanges to minimum requirements  Gradle 6.3+. 5.6.x도 지원하지만 deprecated 되었다. jetty 9.4.22+  Validation Starter no longer included in web starters Web과 WebFlux starters는 validation Starter는 기본적으로 더 이상 의존하지 않는다.\n스스로 starter추가가 필요하다. 이렇게 판단한 이유는 아래 깃에서 확인할 수 있다.\n(많은 application이 validation features를 사용하지 않는다고 판단으로 기본 의존성에서 제외했다는데\u0026hellip;)\nissues 19550\nBootstrapMode for JPA repositories 기본 BootstrapMode는 deferred이고 startup 시간 개선했다.\n아래 설정으로 기본값을 바꿀수있다.\nspring.data.jpa.repositories.bootstrap-mode=default  issues 16230\nSpring Cloud Connectors starter has been removed The Spring Cloud Connectors starter was deprecated in 2.2 in favor of Java CFEnv. This starter has been removed, and Spring Cloud Connectors dependencies are no longer included in Spring Boot’s managed dependencies.\nEmbedded Servlet web server threading configuration The configuration properties for configuring the threads used by embedded Servlet web servers (Jetty, Tomcat, and Undertow) have moved to dedicated threads groups. The properties can now be found in server.jetty.threads, server.tomcat.threads, and server.undertow.threads. The old properties remain in a deprecated form to ease migration.\nJava 14 지원 Build OCI images with Cloud Native Buildpacks Cloud Native Buildpacks으로 OCI(Open Container Initiative) images 빌드할 수 있다.\nCloud Native Buildpacks를 이용해서 Docker images 빌드를 위한 지원을 한다.\nspring-boot:build-image와 bootBuildImage task가 추가 되었다.\nPaketo java buildpack이 기본 이미지 생성에 사용되고 있다.\nBuild layered jars for inclusion in a Docker image ???\nPredictable Classpath Ordering When Exploding Fat Jars Fat jars built with Maven and Gradle now include an index file. index file이 포함된다. jar를 풀어졌을때 인덱스 파일은 클래스 경로의 순서가 jar을 직접 실행할 때와 동일한 지 확인하는 데 사용됩니다.\nFat jars(uber-jar) 응용 프로그램을 실행하는데 필요한 클래스와 의존성을 포함한 self-sufficient 아카이브이다.\nhttps://www.baeldung.com/gradle-fat-jar\nSupport of wildcard locations for configuration files 설정파일들을 위해 wildcard가 지원된다.\nSpring boot는 configuration 파일들을 로딩할때 wildcard를 지원한다.\n기본적으로 config/*/ 의 와일드카드 위치가 지원된다.\nconfig properties의 multiple source가 있을 때Kubernetes와 같은 환경에서 유용하다.\n예) mysql과 redis 설정을 분리한다고 할때 아래와 같이 나눌수있다.\n/config/mysql/application.properties /config/redis/application.properties  Graceful shutdown 모든 embedded web servers(Jetty, Reactor Netty, Tomcat, Undertow)과 reactive, Servlet을 기반한 web applications 에 Graceful shutdown이 지원된다.\nserver.shutdown=graceful 설정을 했을때 종료에 대해서 web server는 새로운 요청을 더이상 허용하지 않는다. 그리고 활성화된 요청이 완료되기 위해 grace period 동안 기다린다.\ngrace period는 spring.lifecycle.timeout-per-shutdown-phase이용해서 설정할 수 있다.\nboot-features-graceful-shutdown\nLiveness and Readiness probes. application이 살아있는지 traffic을 제어할 준비가 되었는지 알수 있게 되었다.\nmanagement.health.probes.enabled=true 설정으로 endpoint를 사용할 수 있다.\nliveness : /actuator/health/liveness readiness : /actuator/health/readiness  liveness-and-readiness-probes-with-spring-boot\nConfigurable base path for WebFlux applications 모든 web handlers의 base path를 설정할 수 있다.\nspring.webflux.base-path  Date-Time conversion in web applications web applications내에서 time과 date-time 값의 변환이 application properties로 설정할 수 있다. iso 값을 지원한다. (ISO-8601)\nspring.mvc.format.date spring.mvc.format.date-time spring.mvc.format.time spring.webflux.format.date spring.webflux.format.date-time spring.webflux.format.time  web-properties\nActuator Improvements RSocket support for Spring Integration RSocket auto-configuration을 제공한다.\nBinding to Period 기간특성이 필요하다면 java.time.Period를 사용하면 된다.\nSlice test for Web Services @WebServiceClientTest는 web services의 slice testing을 지원한다.\nMiscellaneous(잡다한.. 그외)\nDeprecations in Spring Boot 2.3\n"
},
{
	"uri": "https://bbb-86-ko.github.io/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://bbb-86-ko.github.io/%EA%B0%9C%EB%B0%9C%EC%9E%90/jdk/jdk14/",
	"title": "jdk 14",
	"tags": [],
	"description": "",
	"content": "https://openjdk.java.net/projects/jdk/14/  Features 305:\tPattern Matching for instanceof (Preview) instanceof에 Pattern matching을 지원하는 기능이 이야기 되고 있는 것으로 보인다.\nSummary Pattern matching allows common logic in a program\n기존 instanceof 사용의 예. if (obj instanceof String) { String s = (String) obj; // use s } Motivation 기존의 처리는 1) type 확인, 2) type casting, 3) 새로운 local variable를 사용하고있다. 이런 사용은 코드를 장황하게 만든다. 그리고 3가지의 요인으로 프로그램에 에러가 발생할 수있는 상황을 만들 수있다. 그래서 java가 pattern matching을 수용해야 한다고 생각하였다.\nDescription if (obj instanceof String s) { // can use s here } else { // can't use s here } 위 조건문 내에서 만약 obj instanceof String이 true이면 obj를 String으로 casting 후 binding variable s에 값을 할당한다. 그리고 true block 안에서 binding variable s는 유요한 상태이다. 만약 if의 결과가 false인 경우 false block 내에서는 s를 사용할 수없다.\nif (!(obj instanceof String s)) { .. s.contains(..) ..\t// field in the enclosing class } else { .. s.contains(..) ..\t// binding variable } true block의 s는 binding variable가 아니고 class field이다. false block의 s는 binding variable이다. 즉 if 조건이 만족하는 block 에서 binding variable를 사용할 수 있는 것으로 보인다.\nif (obj instanceof String s \u0026amp;\u0026amp; s.length() \u0026gt; 5) {.. s.contains(..) ..} \u0026amp;\u0026amp;의 오른쪽조건은 instanceof가 무조건 true인 경우에만 동작을 한다. 그래서 block내의 s는 binding variable이다.\nif (obj instanceof String s || s.length() \u0026gt; 5) {.. s.contains(..) ..} ||의 경우 s는 binding variable가 아닌 class field이다. (테스트 필요)\n343:\tPackaging Tool (Incubator) 345:\tNUMA-Aware Memory Allocation for G1 349:\tJFR Event Streaming 352:\tNon-Volatile Mapped Byte Buffers 358:\tHelpful NullPointerExceptions 359:\tRecords (Preview) 361:\tSwitch Expressions (Standard) Switch Expressions을 본격적으로 사용이 되는것 같다. switch에 대한 가독성 높고 명확한 code가 가능해진것 같다.\nSummary extend switch는 기존의 \u0026ldquo;case \u0026hellip; :\u0026rdquo; labels과 새로운 \u0026ldquo;case \u0026hellip; -\u0026gt;\u0026rdquo; labels 둘다 사용할 수 있고 switch expression에서 값을 생성 할 수 있는 새로운 statement(yield)가 추가되었다.\n이 변경은 일상적인 코딩을 단순화 할 것이고, switch에서 pattern matching 사용을 위한 방법을 준비한다.\nJDK 12 and JDK 13 preview language feature 였다.\nHistory Switch expressions는 2017년 12월 JEP 325에 의해 제안되었다. JEP 325는 preview feature로 2018년 8월 JDK 12를 대상으로했다.\nJEP 325의 한가지는 break statement의 result value return을 위해 overloading하는 것이었다.\nJEP 325의 또 하나는 switch expression에서 결과 값 return을 위해 break statement의 overloading 하는 것이다. (https://openjdk.java.net/jeps/325)\nJDK 12에 대한 피드백으로 이 같은 break 사용은 혼란스럽다 제안되었다. 피드백에 대한 응답으로, JEP 354는 JEP 325의 진화로 만들어 졌고 새로운 statement, yield 그리고 break 본래 의미 복원을 제안했다. (JEP 354는 2019년 6월 JDK 13을 대상으로 preview feature을 제공했다.)\nFeedback on JDK 13 suggested that switch expressions were ready to become final and permanent in JDK 14 with no further changes. JDK 13의 피드백은 switch expressions는 JDK 14에서 더이상 변경되지 않고 최종적이고 영구적이 될 준비가 되었다고 제안했다.\nMotivation As we prepare to enhance the Java programming language to support pattern matching (JEP 305), several irregularities of the existing switch statement \u0026ndash; which have long been an irritation to users \u0026ndash; become impediments. pattern matching 지원하여 Java를 향상시킬 준비를 할 때(JEP 305), 몇몇 불규칙성들이 \u0026ndash; 오랜시간 사용자에게 짜증나게 하는것 \u0026ndash; 장애가 되었다.\nJava\u0026rsquo;s switch statement의 현재 설계는 C and C++ 같은 언어를 따른다.\n이전의 control flow은 low-level code 작성에는 유용하지만(such as parsers for binary encodings) switch가 higher-level contexts에서 사용되므로써 오류가 발생하기 쉬운 특성이 유연성보다 높아졌다.\n기존 switch 사용의 예 switch (day) { case MONDAY: case FRIDAY: case SUNDAY: System.out.println(6); break; case TUESDAY: System.out.println(7); break; case THURSDAY: case SATURDAY: System.out.println(8); break; case WEDNESDAY: System.out.println(9); break; } 많은 break statements는 불픽요하게 장황하고 visual noise(가독성?)는 종종 오류를 디버그하기 어렵게 만든다.\n신규 switch 사용의 예 switch (day) { case MONDAY, FRIDAY, SUNDAY -\u0026gt; System.out.println(6); case TUESDAY -\u0026gt; System.out.println(7); case THURSDAY, SATURDAY -\u0026gt; System.out.println(8); case WEDNESDAY -\u0026gt; System.out.println(9); } 우리는 case L이 매칭되면 오른쪽의 label만 실행되는 새로운 형태의 switch label \u0026ldquo;case L -\u0026gt;\u0026rdquo; 소개를 제안한다. 또한 commas 구분으로 단일 case multiple constants 허용한다.\n\u0026ldquo;case L -\u0026gt;\u0026rdquo; switch label 의 오른쪽 코드는 expression(표현식), block, throw statement로 제한된다.\n이는 arm이 local variable를 도입해야하는 결과를 가져왔다. (switch block 안의 다른 arm에 대한 scope에는 속하지 않는다.) 그리고 이전에 전체 block이었던 switch block에서의 성가신것을 제거한다.\nswitch (day) { case MONDAY: case TUESDAY: int temp = ... // The scope of 'temp' continues to the } break; case WEDNESDAY: case THURSDAY: int temp2 = ... // Can't call this variable 'temp' break; default: int temp3 = ... // Can't call this variable 'temp' } 위 코드는 temp의 범위는 switch block 전체지만 각 arm에서는 사용할 수 없는 문제점을 보여준다.\nint numLetters; switch (day) { case MONDAY: case FRIDAY: case SUNDAY: numLetters = 6; break; case TUESDAY: numLetters = 7; break; case THURSDAY: case SATURDAY: numLetters = 8; break; case WEDNESDAY: numLetters = 9; break; default: throw new IllegalStateException(\u0026quot;Wat: \u0026quot; + day); } 위 코드는 switch statements는 switch expressions의 시뮬레이션이고, 각 arm은 공통 target variable 또는 returns value 둘 중 하나에 할당하고 있다.\n이 같은 표현은 우회적이며(roundabout), 반복적이고(repetitive) 오류발생이 쉽다(error-prone).\nint numLetters = switch (day) { case MONDAY, FRIDAY, SUNDAY -\u0026gt; 6; case TUESDAY -\u0026gt; 7; case THURSDAY, SATURDAY -\u0026gt; 8; case WEDNESDAY -\u0026gt; 9; }; 위 코드는 switch expression을 사용하였고 이 같은 switch expression은 이전의 코드보다 더 명확하고 안전한하다.\nDescription 1) Arrow labels \u0026ldquo;case L -\u0026gt;\u0026rdquo; labels을 추가하였고 만약 L이 매치되며 \u0026ldquo;-\u0026gt;\u0026rdquo; 오른쪽을 실행한다.\nFor example, given the following switch statement that uses the new form of labels: static void howMany(int k) { switch (k) { case 1 -\u0026gt; System.out.println(\u0026quot;one\u0026quot;); case 2 -\u0026gt; System.out.println(\u0026quot;two\u0026quot;); default -\u0026gt; System.out.println(\u0026quot;many\u0026quot;); } } The following code: howMany(1); howMany(2); howMany(3); results in the following output: one two many 2) Switch expressions switch statement를 expression으로 사용할 수 있다.\nstatic void howMany(int k) { System.out.println( switch (k) { case 1 -\u0026gt; \u0026quot;one\u0026quot;; case 2 -\u0026gt; \u0026quot;two\u0026quot;; default -\u0026gt; \u0026quot;many\u0026quot;; } ); } In the common case, a switch expression will look like: T result = switch (arg) { case L1 -\u0026gt; e1; case L2 -\u0026gt; e2; default -\u0026gt; e3; }; switch expression는 poly expression이다. 만약 target type을 알고있다면 target type 은 각 arm으로 적용된다.\ntype을 알고 있으면 switch expression의 type은 target type이다. 만약 그렇지 않으면 standalone type은 각 case arm의 유형을 합하여 계산됩니다. (arm에서 서로 다른 타입을 전달하면 어떻게 되는지??)\n3) Yielding a value 대부분의 switch expressions는 \u0026ldquo;case L -\u0026gt;\u0026rdquo; switch label 오른쪽에 single expression을 가지고 있다.\nfull block을 사용하고 return value가 필요한 경우 enclosing switch expression으로 yield를 사용한다.\nint j = switch (day) { case MONDAY -\u0026gt; 0; case TUESDAY -\u0026gt; 1; default -\u0026gt; { int k = day.toString().length(); int result = f(k); yield result; } }; 위 코드에서 yield result 를 사용하여 return 하고 있다.\nyield는 이전의 \u0026ldquo;case L:\u0026rdquo; switch labels에서도 사용 할 수 있다.\nint result = switch (s) { case \u0026quot;Foo\u0026quot;: yield 1; case \u0026quot;Bar\u0026quot;: yield 2; default: System.out.println(\u0026quot;Neither Foo nor Bar, hmmm...\u0026quot;); yield 0; }; 위 코드는 이전 switch labels에서의 yield 사용을 예로 보여준다.\nbreak 및 yield의 두 statements는 switch statements과 switch expressions 간에 쉽게 구분 할 수 있다. switch statement는 break statement의 target일 수 있지만 switch expression는 아니다. 반대로 switch expression은 yield statement의 target일 수 있지만 switch statement는 아니다. (이해가 안된다.)\nyield는 제한된 식별자이다.(var) 클래스 이름으로 yield는 불가하다.\n4) Exhaustiveness switch expression의 경우 가능한 모든 값에 매치되는 switch label이어야 한다.\n실제로 이것은 default가 필요함을 의미한다. 그러나 알려진 모든 constants를 포괄하는 enum switch expression의 경우 enum definition가 compile-time과 runtime간에 변경되었음을 나타내는 default 절이 compiler에 의해 삽입됩니다.\nimplicit default clause 삽입을 사용하면 코드가 좋아진다. 이제 코드가 다시 컴파일 될 때 컴파일러는 모든 사례가 명시 적으로 처리되는지 확인합니다.\ndeveloper가 explicit default clause를 하면 가능한 error를 숨길 것이다.\nswitch expression은 value 또는 exception으로 완료하여한다.\n이것은 많은 결과를 초래한다.\ncompiler는 모든 switch label에 대해 일치하고 값을 얻을 수 있는지 검사한다.\nint i = switch (day) { case MONDAY -\u0026gt; { System.out.println(\u0026quot;Monday\u0026quot;); // ERROR! Block doesn't contain a yield statement } default -\u0026gt; 1; }; i = switch (day) { case MONDAY, TUESDAY, WEDNESDAY: yield 0; default: System.out.println(\u0026quot;Second half of the week\u0026quot;); // ERROR! Group doesn't contain a yield statement }; 위 코드는 compiler의 switch label 확인 결과를 보여준다.\ncontrol statements, break, yield, return 및 continue는 다음과 같이 switch expression을 넘을 수 없다.\nz: for (int i = 0; i \u0026lt; MAX_VALUE; ++i) { int k = switch (e) { case 0: yield 1; case 1: yield 2; default: continue z; // ERROR! Illegal jump through a switch expression }; ... } Dependencies 이 JEP는 JEP 325와 JEP 354로부터 확장되었지만 두 JEP에 의존하지 않는다. JEP 305로 시작하는 패턴 일치에 대한 향후 지원은 이 JEP를 기반으로합니다.\n362:\tDeprecate the Solaris and SPARC Ports 363:\tRemove the Concurrent Mark Sweep (CMS) Garbage Collector Concurrent Mark Sweep (CMS) Garbage Collector를 삭제 한다고 한다.\nNon-Goals  다른 GC 삭제는 목표는 아니다. JEP를 대상으로하는 릴리스와 이전의 릴리스에서 CMS GC 삭제는 목표가 아니다.  CMS GC를 삭제하는 이유. 2년전 JEP 291에서는 우리는 다른 collectors의 개발을 가속화 하고 미래 릴리즈에서 삭제를 위해 CMS collector 사용하지 않았다. 이 시간 동안, 신뢰할 수 있는 contributors가 CMS 유지 관리를 시작하지 않았다.(??이해를 못함.)\n이 시간 동안, contributors는 CMS 유지 관리를 시작하지 않았다.\n그리고 또한 JDK 6 CMS의 후속 모델인 G1의 추가 개선 사항과 함께 두가지 새로운 collectors를 소개하였다.(ZGC, Shenandoah)\n이 시점에서 Hotspot JVM에서 사용 가능한 GC가 만약 CMS 성능을 능가하지 않는 경우 CMS를 제거하기에 충분한 오버 헤드가 있다.\n향후 기존 GC의 개선으로 CMS의 필요성이 더욱 줄어들 것으로 예상된다.\n설명 이 변경으로 CMS 컴파일이 비활성화되고 소스트리에서 gc/cms 디렉토리의 내용이 제거되고 CMS에만 관련된 옵션이 제거된다.\n또한 문서에서 CMS에 대한 References는 제거된다.\n그리고 CMS를 사용하려는 테스트는 제거되거나 필요에 따라 적용된다.\n메시지 Trying to use CMS via the -XX:+UseConcMarkSweepGC option will result in the following warning message:\nJava HotSpot(TM) 64-Bit Server VM warning: Ignoring option UseConcMarkSweepGC; \\ support was removed in \u0026lt;version\u0026gt; and the VM will continue execution using the default collector. 대안 CMS를 위한 코드는 repository 안에 유지할 수 있지만 컴파일 할 수 없습니다.\n사용자는 G1 GC 또는 다른 collectors 옮길수 있습니다.\n절대적으로 CMS가 필요한 사용자는 이전 릴리스에서 지원되는 동안 사용할 수 있습니다.\n364:\tZGC on macOS 365:\tZGC on Windows 366:\tDeprecate the ParallelScavenge + SerialOld GC Combination 367:\tRemove the Pack200 Tools and API 368:\tText Blocks (Second Preview) 370:\tForeign-Memory Access API (Incubator) "
},
{
	"uri": "https://bbb-86-ko.github.io/%EA%B0%9C%EB%B0%9C%EC%9E%90/jdk/",
	"title": "jdk release note",
	"tags": [],
	"description": "",
	"content": "  jdk 14   "
},
{
	"uri": "https://bbb-86-ko.github.io/%EA%B0%9C%EB%B0%9C%EC%9E%90/spring-boot/",
	"title": "Spring Boot Release Notes",
	"tags": [],
	"description": "",
	"content": "  2.3.X   "
},
{
	"uri": "https://bbb-86-ko.github.io/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://bbb-86-ko.github.io/%EA%B8%88%EC%9C%B5%EC%96%B4%EB%A6%B0%EC%9D%B4/%EB%8F%85%EC%84%9C/%ED%88%AC%EC%9E%90%EC%97%90%EB%8C%80%ED%95%9C%EC%83%9D%EA%B0%81/",
	"title": "투자에 대한 생각",
	"tags": [],
	"description": "",
	"content": "투자에 대한 생각  01. 심층적으로 생각하라   02. 시장의 효율성을 이해하라   03. 가치란 무엇인가   04. 가격과 가치 사이의 관계를 이해하라   05. 리스크란 무엇인가?   "
}]