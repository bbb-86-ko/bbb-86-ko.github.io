[
{
	"uri": "https://bbb-86-ko.github.io/%EA%B0%9C%EB%B0%9C%EC%9E%90/",
	"title": "개발자",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://bbb-86-ko.github.io/%EA%B8%88%EC%9C%B5%EC%96%B4%EB%A6%B0%EC%9D%B4/",
	"title": "금(융어)린이",
	"tags": [],
	"description": "",
	"content": "금린이의 투자공부 Basics Discover what this Hugo theme is all about and the core-concepts behind it.\n"
},
{
	"uri": "https://bbb-86-ko.github.io/%EA%B8%88%EC%9C%B5%EC%96%B4%EB%A6%B0%EC%9D%B4/%EB%8F%85%EC%84%9C/",
	"title": "독서",
	"tags": [],
	"description": "",
	"content": "금린이의 투자공부 - 독서 Basics Discover what this Hugo theme is all about and the core-concepts behind it.\n"
},
{
	"uri": "https://bbb-86-ko.github.io/%EA%B8%88%EC%9C%B5%EC%96%B4%EB%A6%B0%EC%9D%B4/%EB%8F%85%EC%84%9C/%ED%88%AC%EC%9E%90%EC%97%90%EB%8C%80%ED%95%9C%EC%83%9D%EA%B0%81/01.-%EC%8B%AC%EC%B8%B5%EC%A0%81%EC%9C%BC%EB%A1%9C-%EC%83%9D%EA%B0%81%ED%95%98%EB%9D%BC/",
	"title": "01. 심층적으로 생각하라",
	"tags": [],
	"description": "",
	"content": "투자 전략은 직관적이고 유연해야한다. 투자에는 언제나 적용 가능한 규칙은 없다.\n환경은 통제불가능하고 상황이 똑같이 반복되는 일은 드물기때문이다.\n또한 투자자의 심리가 시장에서 중요하게 작용하고 많은 변수에 영향을 받는다.\n그래서 투자 전략은 지속되지 않고 공식화 할 수 없다.\n그렇기 때문에 투자 전략은 직관적이고 유연해야한다.\n2차 사고(second-level thinking) 2차 사고는 다른 투자자들보다 더 현명하게 사고하는 것이며 남들과 다르면서 남들보다 더 나아가있는 것이다.\n성공적인 투자자는 시장 또는 다른투자자 보다 높은 수익을 낸다.\n그런데 성공적인 투자자는 운일수도 있고 탁월한 통찰력일 수 있다.\n성공적인 투자자가 되려면 탁월한 통찰력에 집중을 해야하면 이를 2차 사고라 할 수 있다.\n다만, 탁월한 통찰력은 누가 가르친다고 생기는 것은 아니며 남들보다 투자에 대한 이해력이 뛰어난 사람이다.\n결론 투자의 목적은 평균이 아닌 평균이상의 수익을 내는것이라 한다면 이를 달성하기 위해서는 2차 사고가 필요하다.\n"
},
{
	"uri": "https://bbb-86-ko.github.io/%EA%B8%88%EC%9C%B5%EC%96%B4%EB%A6%B0%EC%9D%B4/%EB%8F%85%EC%84%9C/%ED%88%AC%EC%9E%90%EC%97%90%EB%8C%80%ED%95%9C%EC%83%9D%EA%B0%81/02.-%EC%8B%9C%EC%9E%A5%EC%9D%98-%ED%9A%A8%EC%9C%A8%EC%84%B1%EC%9D%84-%EC%9D%B4%ED%95%B4%ED%95%98%EB%9D%BC/",
	"title": "02. 시장의 효율성을 이해하라",
	"tags": [],
	"description": "",
	"content": " 작성중\n "
},
{
	"uri": "https://bbb-86-ko.github.io/%EA%B8%88%EC%9C%B5%EC%96%B4%EB%A6%B0%EC%9D%B4/%EB%8F%85%EC%84%9C/%ED%88%AC%EC%9E%90%EC%97%90%EB%8C%80%ED%95%9C%EC%83%9D%EA%B0%81/03.-%EA%B0%80%EC%B9%98%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80/",
	"title": "03. 가치란 무엇인가",
	"tags": [],
	"description": "",
	"content": "투자에서 확실히 성공하려면 가장 먼저 내재가치의 정확한 평가가 이루어져야 한다. 정확한 내재가치 평가 없이 투자자로서 지속적인 성공을 희망하는 것은 말 그대로 희만일 뿐이다.  요약 이번 장에서는 분석방법과 투자방법에 대한 이야기를 하며 내재가치 평가의 중요성에 대하여 기술하였다.\n분석 방법   기본적분석\n 기업의 가치를 분석하는 것이다. 매수 전략 : 기본 내재가치가 가격과 동떨어질때 매수를 한다.    기술적분석\n 증권가격의 동향 분석하는 것이다. 매수 전략 : 미래의 증권가격 동향을 얘측하고 매수를 한다.    기술적분석의 쇠퇴 기술적분석은 과거의 주가의 동향을 분석하여 미래를 예측하게 되는 것인데 이는 마치 동전던지기를 하는 것과 다르지 않다.\n# 랜덤워크 가설 # 과거의 주가 동향은 미래의 주가를 예측하는 데 아무런 도움이 되지 않는다.  증권을 가치 있게 만드는 것은 무엇인가? 자원, 경영진, 공장, 소매상, 특허, 인재, 브랜드인지도, 성장가능성 그리고 소득과 현금유동성을 창출할 수 있는 능력이다.\n기본적 분석   가치투자\n 내재가치보다 싼 증권에 투자를 한다. 재무재표를 활용하여 기업의 현재가치를 수량화 하여 내재가치를 판단하고 가격이 싸다고 판단하면 투자를 한다. 유형자산, 현금유동성을 중요하게 생각한다. 순운전자본투자(net-net- investing)    성장투자\n 가치투자와 모멘텀투자 중간쯤에 있다. 미래의 가치가 빠르게 상승할 증권에 투자를 한다. 잠재력, 장미 빛 미래와 같은 미래의 가치에 투자를 한다.    공통점\n 두가지 모두 내재가치에 대한 판단은 필요하고 미래를 대상으로 하고 있다.    차이점\n 가치투자는 미래보다 현재가 낮은 상황이고, 성장투자는 현재보다 미래가 높은 상황이다. 성장투자자의 성공률은 낮다. 현재보다 미래를 아는 것이 더 어렵기 때문이다.    가치투자 쉬운가? NO 가치투자의 수익 = [내재가치에 대한 정확한 판단] + [확고한 신념]   정확하게 평가하는 것이 중요하다. 자산을 계속 보유해야한다.  내재가치를 올바르게 평가를 하였다고 해도 지금 당장 옳다고 입증되지는 않는다.   확고한 신념이 있어야한다.  확고한 신념으로 수익이 발생하지 않는 기간을 버텨야한다.    결론 미래의 주가를 판단할때 과거 주가의 동향으로 판단하는 것은 좋지 못하다.\n투자에 있어 내재가치 평가는 중요하며 평가 결과는 정확해야 한다.\n정확한 평가를 하여도 확고한 신념이 없으면 수익을 낼 수 없다.\n내재가치에 대한 정확한 판단과 확고한 신념이 함께 이루어져야 수익을 낼 수 잇다.\n"
},
{
	"uri": "https://bbb-86-ko.github.io/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://bbb-86-ko.github.io/",
	"title": "Hugo Learn Documentation",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://bbb-86-ko.github.io/%EA%B0%9C%EB%B0%9C%EC%9E%90/jdk/jdk14/",
	"title": "jdk 14",
	"tags": [],
	"description": "",
	"content": "https://openjdk.java.net/projects/jdk/14/  Features 305:\tPattern Matching for instanceof (Preview) instanceof에 Pattern matching을 지원하는 기능이 이야기 되고 있는 것으로 보인다.\nSummary Pattern matching allows common logic in a program\n기존 instanceof 사용의 예. if (obj instanceof String) { String s = (String) obj; // use s } Motivation 기존의 처리는 1) type 확인, 2) type casting, 3) 새로운 local variable를 사용하고있다. 이런 사용은 코드를 장황하게 만든다. 그리고 3가지의 요인으로 프로그램에 에러가 발생할 수있는 상황을 만들 수있다. 그래서 java가 pattern matching을 수용해야 한다고 생각하였다.\nDescription if (obj instanceof String s) { // can use s here } else { // can't use s here } 위 조건문 내에서 만약 obj instanceof String이 true이면 obj를 String으로 casting 후 binding variable s에 값을 할당한다. 그리고 true block 안에서 binding variable s는 유요한 상태이다. 만약 if의 결과가 false인 경우 false block 내에서는 s를 사용할 수없다.\nif (!(obj instanceof String s)) { .. s.contains(..) ..\t// field in the enclosing class } else { .. s.contains(..) ..\t// binding variable } true block의 s는 binding variable가 아니고 class field이다. false block의 s는 binding variable이다. 즉 if 조건이 만족하는 block 에서 binding variable를 사용할 수 있는 것으로 보인다.\nif (obj instanceof String s \u0026amp;\u0026amp; s.length() \u0026gt; 5) {.. s.contains(..) ..} \u0026amp;\u0026amp;의 오른쪽조건은 instanceof가 무조건 true인 경우에만 동작을 한다. 그래서 block내의 s는 binding variable이다.\nif (obj instanceof String s || s.length() \u0026gt; 5) {.. s.contains(..) ..} ||의 경우 s는 binding variable가 아닌 class field이다. (테스트 필요)\n343:\tPackaging Tool (Incubator) 345:\tNUMA-Aware Memory Allocation for G1 349:\tJFR Event Streaming 352:\tNon-Volatile Mapped Byte Buffers 358:\tHelpful NullPointerExceptions 359:\tRecords (Preview) 361:\tSwitch Expressions (Standard) Switch Expressions을 본격적으로 사용이 되는것 같다. switch에 대한 가독성 높고 명확한 code가 가능해진것 같다.\nSummary extend switch는 기존의 \u0026ldquo;case \u0026hellip; :\u0026rdquo; labels과 새로운 \u0026ldquo;case \u0026hellip; -\u0026gt;\u0026rdquo; labels 둘다 사용할 수 있고 switch expression에서 값을 생성 할 수 있는 새로운 statement(yield)가 추가되었다.\n이 변경은 일상적인 코딩을 단순화 할 것이고, switch에서 pattern matching 사용을 위한 방법을 준비한다.\nJDK 12 and JDK 13 preview language feature 였다.\nHistory Switch expressions는 2017년 12월 JEP 325에 의해 제안되었다. JEP 325는 preview feature로 2018년 8월 JDK 12를 대상으로했다.\nJEP 325의 한가지는 break statement의 result value return을 위해 overloading하는 것이었다.\nJEP 325의 또 하나는 switch expression에서 결과 값 return을 위해 break statement의 overloading 하는 것이다. (https://openjdk.java.net/jeps/325)\nJDK 12에 대한 피드백으로 이 같은 break 사용은 혼란스럽다 제안되었다. 피드백에 대한 응답으로, JEP 354는 JEP 325의 진화로 만들어 졌고 새로운 statement, yield 그리고 break 본래 의미 복원을 제안했다. (JEP 354는 2019년 6월 JDK 13을 대상으로 preview feature을 제공했다.)\nFeedback on JDK 13 suggested that switch expressions were ready to become final and permanent in JDK 14 with no further changes. JDK 13의 피드백은 switch expressions는 JDK 14에서 더이상 변경되지 않고 최종적이고 영구적이 될 준비가 되었다고 제안했다.\nMotivation As we prepare to enhance the Java programming language to support pattern matching (JEP 305), several irregularities of the existing switch statement \u0026ndash; which have long been an irritation to users \u0026ndash; become impediments. pattern matching 지원하여 Java를 향상시킬 준비를 할 때(JEP 305), 몇몇 불규칙성들이 \u0026ndash; 오랜시간 사용자에게 짜증나게 하는것 \u0026ndash; 장애가 되었다.\nJava\u0026rsquo;s switch statement의 현재 설계는 C and C++ 같은 언어를 따른다.\n이전의 control flow은 low-level code 작성에는 유용하지만(such as parsers for binary encodings) switch가 higher-level contexts에서 사용되므로써 오류가 발생하기 쉬운 특성이 유연성보다 높아졌다.\n기존 switch 사용의 예 switch (day) { case MONDAY: case FRIDAY: case SUNDAY: System.out.println(6); break; case TUESDAY: System.out.println(7); break; case THURSDAY: case SATURDAY: System.out.println(8); break; case WEDNESDAY: System.out.println(9); break; } 많은 break statements는 불픽요하게 장황하고 visual noise(가독성?)는 종종 오류를 디버그하기 어렵게 만든다.\n신규 switch 사용의 예 switch (day) { case MONDAY, FRIDAY, SUNDAY -\u0026gt; System.out.println(6); case TUESDAY -\u0026gt; System.out.println(7); case THURSDAY, SATURDAY -\u0026gt; System.out.println(8); case WEDNESDAY -\u0026gt; System.out.println(9); } 우리는 case L이 매칭되면 오른쪽의 label만 실행되는 새로운 형태의 switch label \u0026ldquo;case L -\u0026gt;\u0026rdquo; 소개를 제안한다. 또한 commas 구분으로 단일 case multiple constants 허용한다.\n\u0026ldquo;case L -\u0026gt;\u0026rdquo; switch label 의 오른쪽 코드는 expression(표현식), block, throw statement로 제한된다.\n이는 arm이 local variable를 도입해야하는 결과를 가져왔다. (switch block 안의 다른 arm에 대한 scope에는 속하지 않는다.) 그리고 이전에 전체 block이었던 switch block에서의 성가신것을 제거한다.\nswitch (day) { case MONDAY: case TUESDAY: int temp = ... // The scope of 'temp' continues to the } break; case WEDNESDAY: case THURSDAY: int temp2 = ... // Can't call this variable 'temp' break; default: int temp3 = ... // Can't call this variable 'temp' } 위 코드는 temp의 범위는 switch block 전체지만 각 arm에서는 사용할 수 없는 문제점을 보여준다.\nint numLetters; switch (day) { case MONDAY: case FRIDAY: case SUNDAY: numLetters = 6; break; case TUESDAY: numLetters = 7; break; case THURSDAY: case SATURDAY: numLetters = 8; break; case WEDNESDAY: numLetters = 9; break; default: throw new IllegalStateException(\u0026quot;Wat: \u0026quot; + day); } 위 코드는 switch statements는 switch expressions의 시뮬레이션이고, 각 arm은 공통 target variable 또는 returns value 둘 중 하나에 할당하고 있다.\n이 같은 표현은 우회적이며(roundabout), 반복적이고(repetitive) 오류발생이 쉽다(error-prone).\nint numLetters = switch (day) { case MONDAY, FRIDAY, SUNDAY -\u0026gt; 6; case TUESDAY -\u0026gt; 7; case THURSDAY, SATURDAY -\u0026gt; 8; case WEDNESDAY -\u0026gt; 9; }; 위 코드는 switch expression을 사용하였고 이 같은 switch expression은 이전의 코드보다 더 명확하고 안전한하다.\nDescription 1) Arrow labels \u0026ldquo;case L -\u0026gt;\u0026rdquo; labels을 추가하였고 만약 L이 매치되며 \u0026ldquo;-\u0026gt;\u0026rdquo; 오른쪽을 실행한다.\nFor example, given the following switch statement that uses the new form of labels: static void howMany(int k) { switch (k) { case 1 -\u0026gt; System.out.println(\u0026quot;one\u0026quot;); case 2 -\u0026gt; System.out.println(\u0026quot;two\u0026quot;); default -\u0026gt; System.out.println(\u0026quot;many\u0026quot;); } } The following code: howMany(1); howMany(2); howMany(3); results in the following output: one two many 2) Switch expressions switch statement를 expression으로 사용할 수 있다.\nstatic void howMany(int k) { System.out.println( switch (k) { case 1 -\u0026gt; \u0026quot;one\u0026quot;; case 2 -\u0026gt; \u0026quot;two\u0026quot;; default -\u0026gt; \u0026quot;many\u0026quot;; } ); } In the common case, a switch expression will look like: T result = switch (arg) { case L1 -\u0026gt; e1; case L2 -\u0026gt; e2; default -\u0026gt; e3; }; switch expression는 poly expression이다. 만약 target type을 알고있다면 target type 은 각 arm으로 적용된다.\ntype을 알고 있으면 switch expression의 type은 target type이다. 만약 그렇지 않으면 standalone type은 각 case arm의 유형을 합하여 계산됩니다. (arm에서 서로 다른 타입을 전달하면 어떻게 되는지??)\n3) Yielding a value 대부분의 switch expressions는 \u0026ldquo;case L -\u0026gt;\u0026rdquo; switch label 오른쪽에 single expression을 가지고 있다.\nfull block을 사용하고 return value가 필요한 경우 enclosing switch expression으로 yield를 사용한다.\nint j = switch (day) { case MONDAY -\u0026gt; 0; case TUESDAY -\u0026gt; 1; default -\u0026gt; { int k = day.toString().length(); int result = f(k); yield result; } }; 위 코드에서 yield result 를 사용하여 return 하고 있다.\nyield는 이전의 \u0026ldquo;case L:\u0026rdquo; switch labels에서도 사용 할 수 있다.\nint result = switch (s) { case \u0026quot;Foo\u0026quot;: yield 1; case \u0026quot;Bar\u0026quot;: yield 2; default: System.out.println(\u0026quot;Neither Foo nor Bar, hmmm...\u0026quot;); yield 0; }; 위 코드는 이전 switch labels에서의 yield 사용을 예로 보여준다.\nbreak 및 yield의 두 statements는 switch statements과 switch expressions 간에 쉽게 구분 할 수 있다. switch statement는 break statement의 target일 수 있지만 switch expression는 아니다. 반대로 switch expression은 yield statement의 target일 수 있지만 switch statement는 아니다. (이해가 안된다.)\nyield는 제한된 식별자이다.(var) 클래스 이름으로 yield는 불가하다.\n4) Exhaustiveness switch expression의 경우 가능한 모든 값에 매치되는 switch label이어야 한다.\n실제로 이것은 default가 필요함을 의미한다. 그러나 알려진 모든 constants를 포괄하는 enum switch expression의 경우 enum definition가 compile-time과 runtime간에 변경되었음을 나타내는 default 절이 compiler에 의해 삽입됩니다.\nimplicit default clause 삽입을 사용하면 코드가 좋아진다. 이제 코드가 다시 컴파일 될 때 컴파일러는 모든 사례가 명시 적으로 처리되는지 확인합니다.\ndeveloper가 explicit default clause를 하면 가능한 error를 숨길 것이다.\nswitch expression은 value 또는 exception으로 완료하여한다.\n이것은 많은 결과를 초래한다.\ncompiler는 모든 switch label에 대해 일치하고 값을 얻을 수 있는지 검사한다.\nint i = switch (day) { case MONDAY -\u0026gt; { System.out.println(\u0026quot;Monday\u0026quot;); // ERROR! Block doesn't contain a yield statement } default -\u0026gt; 1; }; i = switch (day) { case MONDAY, TUESDAY, WEDNESDAY: yield 0; default: System.out.println(\u0026quot;Second half of the week\u0026quot;); // ERROR! Group doesn't contain a yield statement }; 위 코드는 compiler의 switch label 확인 결과를 보여준다.\ncontrol statements, break, yield, return 및 continue는 다음과 같이 switch expression을 넘을 수 없다.\nz: for (int i = 0; i \u0026lt; MAX_VALUE; ++i) { int k = switch (e) { case 0: yield 1; case 1: yield 2; default: continue z; // ERROR! Illegal jump through a switch expression }; ... } Dependencies 이 JEP는 JEP 325와 JEP 354로부터 확장되었지만 두 JEP에 의존하지 않는다. JEP 305로 시작하는 패턴 일치에 대한 향후 지원은 이 JEP를 기반으로합니다.\n362:\tDeprecate the Solaris and SPARC Ports 363:\tRemove the Concurrent Mark Sweep (CMS) Garbage Collector Concurrent Mark Sweep (CMS) Garbage Collector를 삭제 한다고 한다.\nNon-Goals  다른 GC 삭제는 목표는 아니다. JEP를 대상으로하는 릴리스와 이전의 릴리스에서 CMS GC 삭제는 목표가 아니다.  CMS GC를 삭제하는 이유. 2년전 JEP 291에서는 우리는 다른 collectors의 개발을 가속화 하고 미래 릴리즈에서 삭제를 위해 CMS collector 사용하지 않았다. 이 시간 동안, 신뢰할 수 있는 contributors가 CMS 유지 관리를 시작하지 않았다.(??이해를 못함.)\n이 시간 동안, contributors는 CMS 유지 관리를 시작하지 않았다.\n그리고 또한 JDK 6 CMS의 후속 모델인 G1의 추가 개선 사항과 함께 두가지 새로운 collectors를 소개하였다.(ZGC, Shenandoah)\n이 시점에서 Hotspot JVM에서 사용 가능한 GC가 만약 CMS 성능을 능가하지 않는 경우 CMS를 제거하기에 충분한 오버 헤드가 있다.\n향후 기존 GC의 개선으로 CMS의 필요성이 더욱 줄어들 것으로 예상된다.\n설명 이 변경으로 CMS 컴파일이 비활성화되고 소스트리에서 gc/cms 디렉토리의 내용이 제거되고 CMS에만 관련된 옵션이 제거된다.\n또한 문서에서 CMS에 대한 References는 제거된다.\n그리고 CMS를 사용하려는 테스트는 제거되거나 필요에 따라 적용된다.\n메시지 Trying to use CMS via the -XX:+UseConcMarkSweepGC option will result in the following warning message:\nJava HotSpot(TM) 64-Bit Server VM warning: Ignoring option UseConcMarkSweepGC; \\ support was removed in \u0026lt;version\u0026gt; and the VM will continue execution using the default collector. 대안 CMS를 위한 코드는 repository 안에 유지할 수 있지만 컴파일 할 수 없습니다.\n사용자는 G1 GC 또는 다른 collectors 옮길수 있습니다.\n절대적으로 CMS가 필요한 사용자는 이전 릴리스에서 지원되는 동안 사용할 수 있습니다.\n364:\tZGC on macOS 365:\tZGC on Windows 366:\tDeprecate the ParallelScavenge + SerialOld GC Combination 367:\tRemove the Pack200 Tools and API 368:\tText Blocks (Second Preview) 370:\tForeign-Memory Access API (Incubator) "
},
{
	"uri": "https://bbb-86-ko.github.io/%EA%B0%9C%EB%B0%9C%EC%9E%90/jdk/",
	"title": "jdk release note",
	"tags": [],
	"description": "",
	"content": "  jdk 14   "
},
{
	"uri": "https://bbb-86-ko.github.io/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://bbb-86-ko.github.io/%EA%B8%88%EC%9C%B5%EC%96%B4%EB%A6%B0%EC%9D%B4/%EB%8F%85%EC%84%9C/%ED%88%AC%EC%9E%90%EC%97%90%EB%8C%80%ED%95%9C%EC%83%9D%EA%B0%81/",
	"title": "투자에 대한 생각",
	"tags": [],
	"description": "",
	"content": "투자에 대한 생각  01. 심층적으로 생각하라   02. 시장의 효율성을 이해하라   03. 가치란 무엇인가   "
}]